<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Map - Dr. Deas Book Log</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        :root {
            --brand-primary: #667eea;
            --brand-secondary: #764ba2;
            --text-light: #ffffff;
            --text-dark: #333;
            --surface-main: rgba(255, 255, 255, 0.95);
            --shadow-light: rgba(0,0,0,0.1);
            --shadow-medium: rgba(0,0,0,0.2);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, var(--brand-primary) 0%, var(--brand-secondary) 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: var(--surface-main);
            padding: 15px 20px;
            box-shadow: 0 2px 10px var(--shadow-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            position: relative;
        }

        .header h1 {
            margin: 0;
            color: var(--text-dark);
            font-size: 1.5em;
        }

        .back-link {
            color: var(--text-dark);
            text-decoration: none;
            font-weight: 600;
            margin-right: 20px;
        }

        .back-link:hover {
            color: var(--brand-primary);
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 0.9em;
            color: var(--text-dark);
            font-weight: 600;
        }

        select, input, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        button {
            background: var(--brand-primary);
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        button:hover {
            background: var(--brand-secondary);
        }

        .visualization-container {
            height: calc(100vh - 80px);
            position: relative;
            overflow: hidden;
        }

        #network-svg {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
            stroke-width: 2px;
        }

        .node:hover {
            stroke-width: 4px;
            stroke-opacity: 1;
        }

        .node.book {
            stroke: #fff;
            opacity: 0.9;
        }

        .node.concept {
            stroke: rgba(255,255,255,0.8);
            opacity: 0.8;
        }

        .node.highlighted {
            stroke: #FFD700;
            stroke-width: 5px;
            opacity: 1;
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .node.important {
            stroke-width: 3px;
            opacity: 1;
        }

        .link {
            stroke: rgba(255,255,255,0.4);
            stroke-width: 1;
            transition: all 0.3s ease;
            opacity: 0.6;
        }

        .link.book-concept {
            stroke: rgba(255,255,255,0.3);
            opacity: 0.4;
        }

        .link.book-book {
            stroke: rgba(255,255,255,0.7);
            stroke-width: 2;
            opacity: 0.7;
        }

        .link.highlighted {
            stroke: #FFD700;
            stroke-width: 4;
            stroke-opacity: 1;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .node-label {
            fill: white;
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .node-label.visible {
            opacity: 1;
        }

        .node-label.permanent {
            opacity: 1;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .tooltip.visible {
            opacity: 1;
        }

        .sidebar {
            position: absolute;
            right: -350px;
            top: 0;
            width: 350px;
            height: 100%;
            background: var(--surface-main);
            box-shadow: -2px 0 10px var(--shadow-medium);
            transition: right 0.3s ease;
            overflow-y: auto;
            z-index: 999;
        }

        .sidebar.open {
            right: 0;
        }

        .sidebar-content {
            padding: 20px;
        }

        .sidebar h3 {
            margin: 0 0 15px 0;
            color: var(--text-dark);
            border-bottom: 2px solid var(--brand-primary);
            padding-bottom: 8px;
        }

        .close-sidebar {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-dark);
        }

        .related-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 8px 0;
            border-radius: 6px;
            border-left: 3px solid var(--brand-primary);
        }

        .related-item h4 {
            margin: 0 0 5px 0;
            color: var(--text-dark);
        }

        .related-item p {
            margin: 0;
            font-size: 13px;
            color: #666;
        }

        .concept-tag {
            display: inline-block;
            background: var(--brand-primary);
            color: white;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 11px;
            margin: 2px;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: var(--surface-main);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-medium);
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: var(--text-dark);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
            font-size: 13px;
        }

        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--surface-main);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-medium);
            min-width: 200px;
        }

        .stats-panel h4 {
            margin: 0 0 10px 0;
            color: var(--text-dark);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 13px;
        }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: white;
            font-size: 18px;
        }

        .complexity-control {
            position: absolute;
            top: 200px;
            left: 20px;
            background: var(--surface-main);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px var(--shadow-medium);
            min-width: 200px;
        }

        .complexity-control h4 {
            margin: 0 0 10px 0;
            color: var(--text-dark);
        }

        .complexity-slider {
            width: 90%;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            
            .control-group {
                width: 100%;
            }
            
            .sidebar {
                width: 100%;
                right: -100%;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div>
            <a href="index.html" class="back-link">‚Üê Back to Book List</a>
            <h1>üß† Dr. Deas Knowledge Map</h1>
        </div>
        <div class="controls">
            <div class="control-group">
                <label>View Mode</label>
                <select id="viewMode">
                    <option value="all">All Connections</option>
                    <option value="books">Books Only</option>
                    <option value="concepts">Concepts Only</option>
                    <option value="category">By Category</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter</label>
                <select id="categoryFilter">
                    <option value="">All Categories</option>
                </select>
            </div>
            <div class="control-group">
                <label>Search</label>
                <input type="text" id="searchInput" placeholder="Search books or concepts...">
            </div>
            <button id="resetBtn">Reset View</button>
            <button id="centerBtn">Center Network</button>
        </div>
    </div>

    <div class="visualization-container">
        <div id="loading" class="loading">
            Loading your book collection and generating knowledge map...
        </div>
        
        <svg id="network-svg" style="display: none;"></svg>
        
        <div class="tooltip" id="tooltip"></div>
        
        <div class="sidebar" id="sidebar">
            <button class="close-sidebar" onclick="closeSidebar()">√ó</button>
            <div class="sidebar-content" id="sidebar-content">
                <!-- Dynamic content will be inserted here -->
            </div>
        </div>

        <div class="stats-panel">
            <h4>Network Stats</h4>
            <div class="stat-row">
                <span>Books:</span>
                <span id="bookCount">0</span>
            </div>
            <div class="stat-row">
                <span>Concepts:</span>
                <span id="conceptCount">0</span>
            </div>
            <div class="stat-row">
                <span>Connections:</span>
                <span id="connectionCount">0</span>
            </div>
            <div class="stat-row">
                <span>Visible:</span>
                <span id="visibleCount">0</span>
            </div>
        </div>

        <div class="complexity-control">
            <h4>Network Complexity</h4>
            <label for="complexitySlider">Detail Level:</label>
            <input type="range" id="complexitySlider" class="complexity-slider" min="1" max="3" value="2" step="1">
            <div style="display: flex; justify-content: space-between; font-size: 12px; margin-top: 5px;">
                <span>Simple</span>
                <span>Balanced</span>
                <span>Detailed</span>
            </div>
        </div>

        <div class="legend">
            <h4>Legend</h4>
            <div class="legend-item">
                <div class="legend-circle" style="background: #667eea;"></div>
                <span>Books</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle" style="background: #E91E63;"></div>
                <span>Concepts</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 2px; background: rgba(255,255,255,0.6);"></div>
                <span>Strong Connection</span>
            </div>
            <div class="legend-item">
                <div style="width: 20px; height: 1px; background: rgba(255,255,255,0.4);"></div>
                <span>Weak Connection</span>
            </div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" id="zoomIn">+</button>
            <button class="zoom-btn" id="zoomOut">‚àí</button>
            <button class="zoom-btn" id="fitBtn" style="font-size: 14px;">‚åÇ</button>
        </div>
    </div>

    <script>
        // Sample book data (first 5 books)
        const books = [
            {
                "number": 1,
                "title": "Begin Again: James Baldwin's America and Its Urgent Lessons for Our Own",
                "author": "Eddie S. Glaude, Jr.",
                "category": "Biography",
                "ownership": "Digital",
                "status": "Finished",
                "dateCompleted": "2020-10-03",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00001.jpg",
                "id": 1,
                "summary": "This book offers a powerful examination of American history and identity through the lens of James Baldwin's work. It delves into Baldwin's observations on race, democracy, and the ongoing struggle for justice in the United States, drawing parallels between his era and contemporary challenges. The author argues that Baldwin's insights remain urgently relevant, urging readers to confront uncomfortable truths about the nation's past and present to forge a more equitable future."
            },
            {
                "number": 2,
                "title": "David and Goliath: Underdogs, Misfits, and the Art of Battling Giants",
                "author": "Malcolm Gladwell",
                "category": "Social Science(s)",
                "ownership": "Physical",
                "status": "Finished",
                "dateCompleted": "2020-10-08",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00002.jpg",
                "id": 2,
                "summary": "This book explores the dynamics of encounters between the powerful and the seemingly weak, challenging conventional wisdom about advantages and disadvantages. It argues that what appears to be a weakness can often be a source of unexpected strength, and that seemingly insurmountable odds can be overcome through unconventional strategies and a refusal to conform to traditional expectations. Through a series of compelling stories and examples, the author illustrates how underdogs can defy expectations and achieve remarkable success by leveraging their unique circumstances and embracing alternative approaches."
            },
            {
                "number": 3,
                "title": "Talking to Strangers: What We Should Know about the People We Don't Know",
                "author": "Malcolm Gladwell",
                "category": "Social Science(s)",
                "ownership": "Digital",
                "status": "Finished",
                "dateCompleted": "2020-10-13",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00003.jpg",
                "id": 3,
                "summary": "This book explores the misunderstandings and miscommunications that arise when people interact with strangers. It delves into the various tools and strategies individuals use to make sense of those they don't know, and how these methods can often lead to incorrect assumptions and catastrophic errors. Through a series of compelling stories and case studies, the author examines why trusting strangers can be both essential and dangerous, highlighting the complexities of human interaction and the importance of re-evaluating our default approaches to engaging with the unknown."
            },
            {
                "number": 4,
                "title": "Atomic Habits: An Easy & Proven Way to Build Good Habits & Break Bad Ones",
                "author": "James Clear",
                "category": "Self-Development",
                "ownership": "Physical",
                "status": "Finished",
                "dateCompleted": "2020-10-24",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00004.jpg",
                "id": 4,
                "summary": "This book explores the power of small, consistent actions in achieving significant results. It introduces practical strategies for forming good habits and breaking bad ones, emphasizing the importance of systems over goals. The author details how to make desired behaviors obvious, attractive, easy, and satisfying, offering actionable insights for personal and professional growth."
            },
            {
                "number": 5,
                "title": "When: The Scientific Secrets of Perfect Timing",
                "author": "Dan H. Pink",
                "category": "Self-Development",
                "ownership": "Physical",
                "status": "Finished",
                "dateCompleted": "2020-10-28",
                "customCoverUrl": "https://raw.githubusercontent.com/DrDeas/DrDeasBookLog/refs/heads/main/images/Book_00005.jpg",
                "id": 5,
                "summary": "This book explores the hidden patterns of our days, revealing how the timing of our actions can profoundly impact our success and well-being. Drawing on a wealth of research from psychology, biology, and economics, it delves into the science of \"when,\" offering practical insights on how to optimize our daily schedules, make better decisions, and boost our performance by understanding the natural rhythms of our lives. It highlights the importance of recognizing different \"temporal landmarks\" and utilizing strategic breaks to maximize productivity and personal satisfaction."
            }
        ];

        function loadFullBookData() {
            console.log(`üìö Found ${books.length} books in collection`);
            const finishedBooks = books.filter(book => book.status === 'Finished');
            console.log(`‚úÖ Loaded ${finishedBooks.length} finished books for knowledge map`);
            return finishedBooks;
        }

        const bookData = loadFullBookData();

        // Enhanced Concept Extractor Class
        class ConceptExtractor {
            constructor() {
                this.conceptCategories = {
                    identity: ['identity', 'self', 'belonging', 'authenticity', 'consciousness', 'awareness'],
                    power: ['power', 'authority', 'control', 'dominance', 'influence', 'leadership'],
                    justice: ['justice', 'equality', 'fairness', 'rights', 'freedom', 'liberation'],
                    racism: ['racism', 'racial', 'discrimination', 'prejudice', 'segregation', 'civil rights'],
                    oppression: ['oppression', 'systemic', 'institutional', 'marginalization', 'exploitation'],
                    community: ['community', 'society', 'collective', 'social', 'cultural', 'belonging'],
                    spirituality: ['spiritual', 'faith', 'religion', 'divine', 'sacred', 'transcendence'],
                    creativity: ['creativity', 'art', 'artistic', 'imagination', 'innovation', 'expression'],
                    education: ['education', 'learning', 'knowledge', 'teaching', 'pedagogy', 'intellectual'],
                    technology: ['technology', 'digital', 'artificial intelligence', 'algorithms', 'data'],
                    economics: ['economic', 'wealth', 'capitalism', 'inequality', 'poverty', 'class'],
                    gender: ['gender', 'feminism', 'masculinity', 'women', 'men', 'patriarchy'],
                    philosophy: ['philosophy', 'existence', 'meaning', 'truth', 'reality', 'ethics'],
                    science: ['science', 'research', 'discovery', 'universe', 'evolution', 'physics'],
                    psychology: ['psychology', 'mind', 'behavior', 'consciousness', 'mental', 'emotion'],
                    history: ['history', 'historical', 'past', 'legacy', 'tradition', 'memory'],
                    politics: ['politics', 'government', 'policy', 'democracy', 'political', 'state'],
                    transformation: ['change', 'transformation', 'growth', 'evolution', 'revolution'],
                    resistance: ['resistance', 'rebellion', 'protest', 'activism', 'movement', 'struggle'],
                    love: ['love', 'compassion', 'empathy', 'connection', 'relationship', 'care'],
                    habits: ['habits', 'routine', 'behavior', 'patterns', 'consistent'],
                    timing: ['timing', 'time', 'schedule', 'when', 'rhythm'],
                    communication: ['communication', 'strangers', 'interaction', 'understanding']
                };

                this.specificThemes = {
                    'Black experience': ['black', 'african american', 'harlem', 'slavery', 'jim crow', 'baldwin'],
                    'mindfulness': ['mindfulness', 'meditation', 'present moment', 'awareness', 'peace'],
                    'business innovation': ['startup', 'entrepreneurship', 'innovation', 'disruption'],
                    'artificial intelligence': ['ai', 'machine learning', 'algorithms', 'automation'],
                    'social media': ['social media', 'twitter', 'facebook', 'digital platforms'],
                    'climate change': ['climate', 'environment', 'sustainability', 'green'],
                    'mass incarceration': ['prison', 'incarceration', 'criminal justice', 'policing'],
                    'education reform': ['school', 'curriculum', 'educational system', 'pedagogy'],
                    'mental health': ['depression', 'anxiety', 'trauma', 'healing', 'therapy'],
                    'economic inequality': ['wealth gap', 'poverty', 'economic disparity', 'class'],
                    'gender equality': ['feminist', 'women\'s rights', 'gender roles', 'equality'],
                    'religious thought': ['christianity', 'buddhism', 'theology', 'spiritual practice'],
                    'scientific discovery': ['physics', 'biology', 'cosmology', 'evolution'],
                    'political philosophy': ['democracy', 'authoritarianism', 'political theory'],
                    'creative process': ['artistic creation', 'writing', 'music', 'creative work'],
                    'personal development': ['habits', 'growth', 'improvement', 'development'],
                    'human behavior': ['psychology', 'behavior', 'decision making', 'social']
                };

                this.authorInfluenceMap = {
                    'Eddie S. Glaude, Jr.': ['racial identity', 'civil rights', 'social criticism', 'history'],
                    'Malcolm Gladwell': ['social science', 'human behavior', 'decision making', 'sociology'],
                    'James Clear': ['habits', 'productivity', 'self improvement', 'systems'],
                    'Dan H. Pink': ['timing', 'motivation', 'psychology', 'productivity']
                };
            }

            extractBookConcepts(book) {
                const concepts = new Set();
                const text = `${book.title} ${book.author} ${book.summary || ''}`.toLowerCase();
                
                Object.entries(this.conceptCategories).forEach(([category, keywords]) => {
                    const matchCount = keywords.filter(keyword => text.includes(keyword)).length;
                    if (matchCount > 0) {
                        concepts.add(category);
                    }
                });

                Object.entries(this.specificThemes).forEach(([theme, keywords]) => {
                    const matchCount = keywords.filter(keyword => text.includes(keyword)).length;
                    if (matchCount >= 1) {
                        concepts.add(theme);
                    }
                }); 

                if (book.category) {
                    concepts.add(book.category.toLowerCase());
                }

                if (this.authorInfluenceMap[book.author]) {
                    this.authorInfluenceMap[book.author].forEach(concept => concepts.add(concept));
                }

                return Array.from(concepts);
            }

            extractAllConcepts(books) {
                return books.map(book => ({
                    ...book,
                    concepts: this.extractBookConcepts(book)
                }));
            }

            findRelatedBooks(targetBook, allBooksWithConcepts, minSharedConcepts = 1) {
                const targetConcepts = new Set(targetBook.concepts);
                
                return allBooksWithConcepts
                    .filter(book => book.id !== targetBook.id)
                    .map(book => {
                        const sharedConcepts = book.concepts.filter(concept => targetConcepts.has(concept));
                        return {
                            book,
                            sharedConcepts,
                            connectionStrength: sharedConcepts.length
                        };
                    })
                    .filter(relation => relation.connectionStrength >= minSharedConcepts)
                    .sort((a, b) => b.connectionStrength - a.connectionStrength);
            }

            createConceptFrequencyMap(booksWithConcepts) {
                const conceptFreq = {};
                
                booksWithConcepts.forEach(book => {
                    book.concepts.forEach(concept => {
                        conceptFreq[concept] = (conceptFreq[concept] || 0) + 1;
                    });
                });

                return conceptFreq;
            }

            createConceptNetwork(booksWithConcepts, complexityLevel = 2) {
                const nodes = [];
                const links = [];
                const processedPairs = new Set();

                // Adjust thresholds based on complexity level - make progression more gradual
                const conceptThreshold = complexityLevel === 1 ? 3 : complexityLevel === 2 ? 3 : 2; // Keep Balanced same as Simple
                const maxConcepts = complexityLevel === 1 ? 6 : complexityLevel === 2 ? 10 : 15; // More gradual progression
                const maxBookConnections = complexityLevel === 1 ? 1 : complexityLevel === 2 ? 1 : 2; // Keep Balanced same as Simple

                console.log(`Creating network: complexity=${complexityLevel}, conceptThreshold=${conceptThreshold}, maxConcepts=${maxConcepts}`);

                // Create book nodes with enhanced properties
                booksWithConcepts.forEach(book => {
                    const importance = this.calculateBookImportance(book, booksWithConcepts);
                    nodes.push({
                        id: `book-${book.id}`,
                        type: 'book',
                        title: book.title,
                        author: book.author,
                        category: book.category,
                        concepts: book.concepts,
                        size: Math.min(book.concepts.length * 3 + 12, 30),
                        color: this.getCategoryColor(book.category),
                        dateCompleted: book.dateCompleted,
                        summary: book.summary,
                        importance: importance,
                        isImportant: importance > 0.7
                    });
                });

                // Create concept nodes with importance weighting
                const conceptFreq = this.createConceptFrequencyMap(booksWithConcepts);
                const importantConcepts = Object.entries(conceptFreq)
                    .filter(([concept, freq]) => freq >= conceptThreshold)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, maxConcepts);

                importantConcepts.forEach(([concept, frequency]) => {
                    const importance = frequency / booksWithConcepts.length;
                    nodes.push({
                        id: `concept-${concept}`,
                        type: 'concept',
                        name: concept,
                        frequency,
                        size: Math.min(frequency * 4 + 8, 20),
                        color: this.getConceptColor(concept),
                        importance: importance,
                        isImportant: importance > 0.5
                    });
                });

                // Create book-concept links with strength weighting
                booksWithConcepts.forEach(book => {
                    book.concepts.forEach(concept => {
                        if (conceptFreq[concept] >= conceptThreshold) {
                            links.push({
                                source: `book-${book.id}`,
                                target: `concept-${concept}`,
                                type: 'book-concept',
                                strength: conceptFreq[concept] / booksWithConcepts.length
                            });
                        }
                    });
                });

                // Create book-book links with limited connections
                booksWithConcepts.forEach(book => {
                    const related = this.findRelatedBooks(book, booksWithConcepts, 2);
                    related.slice(0, maxBookConnections).forEach(relation => {
                        const pairKey = [book.id, relation.book.id].sort().join('-');
                        if (!processedPairs.has(pairKey)) {
                            links.push({
                                source: `book-${book.id}`,
                                target: `book-${relation.book.id}`,
                                type: 'book-book',
                                strength: relation.connectionStrength / 5, // Normalize strength
                                sharedConcepts: relation.sharedConcepts
                            });
                            processedPairs.add(pairKey);
                        }
                    });
                });

                console.log(`üéØ Network created: ${nodes.length} nodes, ${links.length} links`);
                return { nodes, links };
            }

            calculateBookImportance(book, allBooks) {
                // Calculate importance based on concept richness and connections
                const conceptCount = book.concepts.length;
                const maxConcepts = Math.max(...allBooks.map(b => b.concepts.length));
                return conceptCount / maxConcepts;
            }

            getCategoryColor(category) {
                const colors = {
                    'Biography': '#F4C430', 'Business': '#CD5C5C', 'Education': '#32CD32',
                    'Essay(s)/Short Stories': '#F0A0A0', 'Finance': '#483D8B', 'Informational': '#4682B4',
                    'Memoir/Autobiography': '#FF8C00', 'Novel': '#DA70D6', 'Philosophy': '#2F4F4F',
                    'Poetry': '#708090', 'Policy and Politics': '#477685', 
                    'Race, Class, and Gender': '#228B22', 'Religion': '#556B2F', 'Science': '#87CEFA',
                    'Self-Development': '#9370DB', 'Social Science(s)': '#A0522D', 'Stage Play': '#5A9678', 
                    'Technology': '#BC8F8F'
                };
                return colors[category] || '#667eea';
            }

            getConceptColor(concept) {
                const conceptColors = {
                    'identity': '#E91E63', 'power': '#9C27B0', 'justice': '#3F51B5',
                    'racism': '#F44336', 'oppression': '#795548', 'community': '#4CAF50',
                    'spirituality': '#FF9800', 'creativity': '#E91E63', 'education': '#2196F3',
                    'technology': '#607D8B', 'economics': '#FFC107', 'gender': '#9C27B0',
                    'philosophy': '#673AB7', 'science': '#00BCD4', 'psychology': '#FF5722',
                    'history': '#8BC34A', 'politics': '#009688', 'transformation': '#CDDC39',
                    'resistance': '#FF6F00', 'love': '#E91E63', 'mindfulness': '#4CAF50',
                    'Black experience': '#F44336', 'artificial intelligence': '#607D8B',
                    'habits': '#9C27B0', 'timing': '#FF9800', 'communication': '#2196F3',
                    'human behavior': '#FF5722', 'personal development': '#9370DB'
                };
                return conceptColors[concept] || '#757575';
            }
        }

        // Enhanced Network Visualization Class
        class NetworkVisualization {
            constructor(containerSelector) {
                this.container = d3.select(containerSelector);
                this.width = window.innerWidth;
                this.height = window.innerHeight - 80;
                this.complexityLevel = 2;
                
                this.initializeSVG();
                this.initializeSimulation();
                this.initializeInteractions();
                this.loadData();
            }

            initializeSVG() {
                const svg = this.container
                    .attr('width', this.width)
                    .attr('height', this.height);

                this.zoomBehavior = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        svg.select('.main-group').attr('transform', event.transform);
                    });

                svg.call(this.zoomBehavior);
                this.g = svg.append('g').attr('class', 'main-group');
                this.tooltip = d3.select('#tooltip');
            }

            initializeSimulation() {
                // Create a basic simulation - will be properly configured in renderNetwork
                this.simulation = d3.forceSimulation();
            }

            initializeInteractions() {
                d3.select('#resetBtn').on('click', () => this.resetView());
                d3.select('#centerBtn').on('click', () => this.centerNetwork());
                d3.select('#zoomIn').on('click', () => this.zoomIn());
                d3.select('#zoomOut').on('click', () => this.zoomOut());
                d3.select('#fitBtn').on('click', () => this.fitToScreen());
                
                // Complexity slider
                d3.select('#complexitySlider').on('input', (event) => {
                    this.complexityLevel = parseInt(event.target.value);
                    this.updateComplexity();
                });
            }

            loadData() {
                if (!bookData || bookData.length === 0) {
                    document.getElementById('loading').innerHTML = `
                        <div style="color: #ff4757; text-align: center;">
                            <h2>‚ùå No book data found!</h2>
                            <p>This is a demo with limited data.</p>
                        </div>
                    `;
                    return;
                }

                const extractor = new ConceptExtractor();
                const booksWithConcepts = extractor.extractAllConcepts(bookData);
                this.booksWithConcepts = booksWithConcepts;
                this.extractor = extractor;
                
                this.updateNetworkData();
                this.updateStats();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('network-svg').style.display = 'block';
                
                this.renderNetwork();
            }

            updateNetworkData() {
                this.networkData = this.extractor.createConceptNetwork(this.booksWithConcepts, this.complexityLevel);
            }

            updateComplexity() {
                this.updateNetworkData();
                this.updateStats();
                this.renderNetwork();
                // Remove the setTimeout - forces are already updated in renderNetwork
            }

            updateForceParameters() {
                if (!this.simulation) return;

                // Use actual current node count, not bookData.length
                const currentNodes = this.simulation.nodes();
                const nodeCount = currentNodes.length;
                const chargeStrength = Math.max(-400 - nodeCount * 10, -1200); // Adjusted calculation

                console.log(`Updating forces for complexity ${this.complexityLevel}, nodeCount: ${nodeCount}, chargeStrength: ${chargeStrength}`);

                // Update link strength based on complexity
                const linkStrength = this.complexityLevel === 1 ? 0.3 : this.complexityLevel === 2 ? 0.4 : 0.2;
                this.simulation.force('link').strength(d => {
                    if (d.type === 'book-book') return linkStrength * 1.2;
                    return linkStrength;
                });

                // Update charge strength - use current node count
                this.simulation.force('charge').strength(d => {
                    return d && d.isImportant ? chargeStrength * 1.5 : chargeStrength;
                });

                // Update clustering forces
                const xStrength = 0.05;
                const yStrength = 0.03;
                this.simulation.force('x').strength(xStrength);
                this.simulation.force('y').strength(yStrength);

                // Use consistent cooling parameters
                this.simulation.alphaDecay(0.008);
                this.simulation.velocityDecay(0.25);
            }

            updateStats() {
                const bookCount = this.networkData.nodes.filter(n => n.type === 'book').length;
                const conceptCount = this.networkData.nodes.filter(n => n.type === 'concept').length;
                const connectionCount = this.networkData.links.length;

                d3.select('#bookCount').text(bookCount);
                d3.select('#conceptCount').text(conceptCount);
                d3.select('#connectionCount').text(connectionCount);
                d3.select('#visibleCount').text(this.networkData.nodes.length);
            }

            renderNetwork() {
                const data = this.networkData;
                
                this.g.selectAll('*').remove();

                // Create the simulation fresh each time with correct parameters
                const nodeCount = data.nodes.length;
                const linkDistance = Math.min(150 + nodeCount * 3, 300);
                const chargeStrength = Math.max(-300 - nodeCount * 8, -800);
                const collisionRadius = 20;

                // Get complexity-specific parameters - reverse the logic
                const linkStrength = this.complexityLevel === 1 ? 0.5 : this.complexityLevel === 2 ? 0.4 : 0.3;

                console.log(`Creating simulation: complexity=${this.complexityLevel}, nodes=${nodeCount}, linkStrength=${linkStrength}, charge=${chargeStrength}`);

                // Stop any existing simulation
                this.simulation.stop();

                // Reconfigure the simulation with correct parameters
                this.simulation
                    .force('link', d3.forceLink()
                        .id(d => d.id)
                        .distance(d => {
                            if (d.type === 'book-book') return linkDistance * 1.3;
                            return linkDistance;
                        })
                        .strength(d => {
                            if (d.type === 'book-book') return linkStrength * 1.2;
                            return linkStrength;
                        })
                    )
                    .force('charge', d3.forceManyBody()
                        .strength(d => {
                            return d && d.isImportant ? chargeStrength * 1.5 : chargeStrength;
                        })
                        .distanceMax(500)
                    )
                    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
                    .force('collision', d3.forceCollide()
                        .radius(d => d.size + collisionRadius)
                        .strength(0.9)
                    )
                    .force('x', d3.forceX()
                        .x(d => {
                            if (d.type === 'book') return this.width * 0.3;
                            return this.width * 0.7;
                        })
                        .strength(0.05)
                    )
                    .force('y', d3.forceY(this.height / 2).strength(0.03))
                    .alphaDecay(0.008)
                    .velocityDecay(0.25);

                // Create links with varying opacity and width
                const link = this.g.append('g')
                    .selectAll('line')
                    .data(data.links)
                    .enter().append('line')
                    .attr('class', d => `link ${d.type}`)
                    .attr('stroke-width', d => {
                        if (d.type === 'book-book') return Math.max(d.strength * 8, 1);
                        return Math.max(d.strength * 4, 0.5);
                    })
                    .attr('opacity', d => Math.max(d.strength * 2, 0.3));

                // Create nodes with enhanced styling
                const node = this.g.append('g')
                    .selectAll('circle')
                    .data(data.nodes)
                    .enter().append('circle')
                    .attr('class', d => `node ${d.type} ${d.isImportant ? 'important' : ''}`)
                    .attr('r', d => d.size)
                    .attr('fill', d => d.color)
                    .attr('opacity', d => d.isImportant ? 1 : 0.8)
                    .call(this.createDragBehavior())
                    .on('mouseover', (event, d) => this.showTooltip(event, d))
                    .on('mouseout', () => this.hideTooltip())
                    .on('click', (event, d) => this.showNodeDetails(d));

                // Create labels with smart visibility
                const labels = this.g.append('g')
                    .selectAll('text')
                    .data(data.nodes)
                    .enter().append('text')
                    .attr('class', d => `node-label ${d.isImportant ? 'permanent' : ''}`)
                    .text(d => {
                        if (d.type === 'book') {
                            return d.title.length > 20 ? d.title.substring(0, 17) + '...' : d.title;
                        } else {
                            return d.name.length > 15 ? d.name.substring(0, 12) + '...' : d.name;
                        }
                    })
                    .attr('dy', 4)
                    .style('font-size', d => d.isImportant ? '13px' : '11px');

                // Initialize nodes with spiral positioning to avoid center clustering
                this.initializeNodePositions(data.nodes);

                this.simulation.nodes(data.nodes);
                this.simulation.force('link').links(data.links);
                
                this.simulation.on('tick', () => {
                    link
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    node
                        .attr('cx', d => d.x)
                        .attr('cy', d => d.y);

                    labels
                        .attr('x', d => d.x)
                        .attr('y', d => d.y);
                });

                // Enhanced label visibility on hover
                node.on('mouseenter', function(event, d) {
                    d3.select(this.parentNode).selectAll('.node-label')
                        .filter(labelData => labelData.id === d.id)
                        .classed('visible', true);
                }).on('mouseleave', function(event, d) {
                    d3.select(this.parentNode).selectAll('.node-label')
                        .filter(labelData => labelData.id === d.id && !labelData.isImportant)
                        .classed('visible', false);
                });

                this.simulation.alpha(1).restart();

                // Gradual cooling for large networks
                setTimeout(() => {
                    this.simulation.alpha(0.3).restart();
                }, 3000);
            }

            initializeNodePositions(nodes) {
                const radius = Math.min(this.width, this.height) * 0.3;
                const centerX = this.width / 2;
                const centerY = this.height / 2;

                nodes.forEach((d, i) => {
                    if (!d.x && !d.y) {
                        // Spiral positioning
                        const angle = (i / nodes.length) * 4 * Math.PI;
                        const r = (i / nodes.length) * radius;
                        d.x = centerX + Math.cos(angle) * r;
                        d.y = centerY + Math.sin(angle) * r;
                    }
                });
            }

            createDragBehavior() {
                return d3.drag()
                    .on('start', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0.3).restart();
                        d.fx = d.x;
                        d.fy = d.y;
                    })
                    .on('drag', (event, d) => {
                        d.fx = event.x;
                        d.fy = event.y;
                    })
                    .on('end', (event, d) => {
                        if (!event.active) this.simulation.alphaTarget(0);
                        d.fx = null;
                        d.fy = null;
                    });
            }

            showTooltip(event, d) {
                let content = '';
                
                if (d.type === 'book') {
                    content = `
                        <strong>${d.title}</strong><br>
                        <em>by ${d.author}</em><br>
                        Category: ${d.category}<br>
                        Concepts: ${d.concepts.length}<br>
                        Importance: ${(d.importance * 100).toFixed(0)}%
                    `;
                } else {
                    content = `
                        <strong>Concept: ${d.name}</strong><br>
                        Appears in ${d.frequency} books<br>
                        Importance: ${(d.importance * 100).toFixed(0)}%
                    `;
                }
                
                this.tooltip.html(content)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .classed('visible', true);
            }

            hideTooltip() {
                this.tooltip.classed('visible', false);
            }

            showNodeDetails(d) {
                const sidebar = d3.select('#sidebar');
                const content = d3.select('#sidebar-content');
                
                if (d.type === 'book') {
                    this.showBookDetails(d, content);
                } else {
                    this.showConceptDetails(d, content);
                }
                
                sidebar.classed('open', true);
                this.highlightConnections(d);
            }

            showBookDetails(book, content) {
                const relatedBooks = this.extractor.findRelatedBooks(
                    book, 
                    this.networkData.nodes.filter(n => n.type === 'book'),
                    1
                );

                content.html(`
                    <h3>üìö ${book.title}</h3>
                    <p><strong>Author:</strong> ${book.author}</p>
                    <p><strong>Category:</strong> ${book.category}</p>
                    <p><strong>Importance:</strong> ${(book.importance * 100).toFixed(0)}%</p>
                    ${book.dateCompleted ? `<p><strong>Completed:</strong> ${book.dateCompleted}</p>` : ''}
                    
                    <h4>Key Concepts</h4>
                    <div>
                        ${book.concepts.map(concept => 
                            `<span class="concept-tag">${concept}</span>`
                        ).join('')}
                    </div>
                    
                    ${book.summary ? `
                        <h4>Summary</h4>
                        <p style="font-size: 13px; line-height: 1.4;">${book.summary}</p>
                    ` : ''}
                    
                    <h4>Related Books</h4>
                    <div>
                        ${relatedBooks.slice(0, 3).map(rel => `
                            <div class="related-item">
                                <h4>${rel.book.title}</h4>
                                <p>${rel.book.author} - ${rel.connectionStrength} shared concepts</p>
                                <p style="font-size: 12px;">Shared: ${rel.sharedConcepts.slice(0, 3).join(', ')}</p>
                            </div>
                        `).join('')}
                    </div>
                `);
            }

            showConceptDetails(concept, content) {
                const relatedBooks = this.networkData.nodes
                    .filter(n => n.type === 'book' && n.concepts.includes(concept.name))
                    .sort((a, b) => new Date(a.dateCompleted || '1900') - new Date(b.dateCompleted || '1900'));

                content.html(`
                    <h3>üí° ${concept.name}</h3>
                    <p><strong>Frequency:</strong> Appears in ${concept.frequency} books</p>
                    <p><strong>Importance:</strong> ${(concept.importance * 100).toFixed(0)}%</p>
                    <p><strong>Theme:</strong> Core concept in your intellectual journey</p>
                    
                    <h4>Books Exploring This Concept</h4>
                    <div>
                        ${relatedBooks.map(book => `
                            <div class="related-item">
                                <h4>${book.title}</h4>
                                <p>${book.author} (${book.dateCompleted || 'Date unknown'})</p>
                                <p style="font-size: 12px;">${book.category}</p>
                            </div>
                        `).join('')}
                    </div>
                `);
            }

            highlightConnections(selectedNode) {
                const connectedIds = new Set();
                connectedIds.add(selectedNode.id);
                
                this.networkData.links.forEach(link => {
                    const sourceId = link.source.id || link.source;
                    const targetId = link.target.id || link.target;
                    
                    if (sourceId === selectedNode.id) connectedIds.add(targetId);
                    if (targetId === selectedNode.id) connectedIds.add(sourceId);
                });

                this.g.selectAll('.node')
                    .classed('highlighted', d => d.id === selectedNode.id)
                    .classed('dimmed', d => !connectedIds.has(d.id));

                this.g.selectAll('.link')
                    .classed('highlighted', d => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        return sourceId === selectedNode.id || targetId === selectedNode.id;
                    })
                    .classed('dimmed', d => {
                        const sourceId = d.source.id || d.source;
                        const targetId = d.target.id || d.target;
                        return sourceId !== selectedNode.id && targetId !== selectedNode.id;
                    });
            }

            clearHighlights() {
                this.g.selectAll('.node')
                    .classed('highlighted', false)
                    .classed('dimmed', false);
                
                this.g.selectAll('.link')
                    .classed('highlighted', false)
                    .classed('dimmed', false);
            }

            resetView() {
                this.clearHighlights();
                const transform = d3.zoomIdentity.translate(this.width / 2, this.height / 2).scale(1);
                this.container.transition().duration(750).call(this.zoomBehavior.transform, transform);
            }

            centerNetwork() {
                const transform = d3.zoomIdentity.translate(this.width / 2, this.height / 2).scale(1);
                this.container.transition().duration(750).call(this.zoomBehavior.transform, transform);
            }

            zoomIn() {
                this.container.transition().duration(300).call(this.zoomBehavior.scaleBy, 1.5);
            }

            zoomOut() {
                this.container.transition().duration(300).call(this.zoomBehavior.scaleBy, 0.67);
            }

            fitToScreen() {
                const bounds = this.g.node().getBBox();
                const parent = this.g.node().parentElement;
                const fullWidth = parent.clientWidth || parent.parentNode.clientWidth;
                const fullHeight = parent.clientHeight || parent.parentNode.clientHeight;
                const width = bounds.width;
                const height = bounds.height;
                const midX = bounds.x + width / 2;
                const midY = bounds.y + height / 2;
                
                if (width == 0 || height == 0) return;
                
                const scale = Math.min(fullWidth / width, fullHeight / height) * 0.8;
                const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
                
                const transform = d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale);
                this.container.transition().duration(750).call(this.zoomBehavior.transform, transform);
            }
        }

        // Global function to close sidebar
        function closeSidebar() {
            d3.select('#sidebar').classed('open', false);
            if (window.network) {
                window.network.clearHighlights();
            }
        }

        // Initialize the visualization when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Initializing Enhanced Knowledge Map...');
            
            if (bookData.length === 0) {
                console.error('‚ùå No finished books found!');
                return;
            }

            window.network = new NetworkVisualization('#network-svg');
            console.log('‚úÖ Enhanced Knowledge Map initialized successfully!');
        });
    </script>
</body>
</html>
